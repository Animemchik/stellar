#![allow(warnings)]
#![doc(
    html_logo_url = "https://raw.githubusercontent.com/quantumatic/stellar/main/additional/icon/stellar.png",
    html_favicon_url = "https://raw.githubusercontent.com/quantumatic/stellar/main/additional/icon/stellar.png"
)]

use parking_lot::{RawRwLock, RwLock, RwLockReadGuard, RwLockWriteGuard};
use paste::paste;
use stellar_ast::{IdentifierAST, Path, Visibility};
use stellar_diagnostics::Diagnostics;
use stellar_filesystem::location::Location;
use stellar_fx_hash::FxHashMap;
use stellar_interner::{IdentifierID, PathID};
use stellar_thir::ty::{Type, TypeConstructor};

macro_rules! define_symbol_struct {
    ($($name:ident),*) => {
        paste! {
            /// A symbol's unique ID.
            #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]
            pub enum Symbol {
                $(
                    #[doc = "A " $name "."]
                    [<$name:camel>]([<$name:camel ID>]),
                )*
            }

            impl Symbol {
                $(
                    #[doc = "Returns `true` if the symbol is a " $name "."]
                    #[doc = ""]
                    #[doc = "_This function is automatically generated by a macro._"]
                    #[inline(always)]
                    #[must_use]
                    pub const fn [<is_ $name>](&self) -> bool {
                        matches!(self, Self::[<$name:camel>](_))
                    }

                    #[doc = "Returns " $name " ID if the symbol is a " $name "."]
                    #[doc = ""]
                    #[doc = "_This function is automatically generated by a macro._"]
                    #[inline(always)]
                    #[must_use]
                    pub fn [<get_ $name _id>](self) -> Option<[<$name:camel ID>]> {
                        match self {
                            Self::[<$name:camel>](id) => Some(id),
                            _ => None
                        }
                    }

                    #[doc = "Returns " $name " ID if the symbol is a " $name "."]
                    #[doc = "# Panics"]
                    #[doc = "Panics if the symbol is not a " $name "."]
                    #[doc = ""]
                    #[doc = "_This function is automatically generated by a macro._"]
                    #[inline(always)]
                    #[must_use]
                    pub fn [<get_ $name _id_or_panic>](self) -> [<$name:camel ID>] {
                        self.[<get_ $name _id>]().unwrap()
                    }

                    #[doc = "Returns " $name " data if the symbol is a " $name "."]
                    #[doc = ""]
                    #[doc = "_This function is automatically generated by a macro._"]
                    #[inline(always)]
                    #[must_use]
                    pub fn [<get_ $name>](self, db: &Database) -> Option<&[<$name:camel Data>]> {
                        db.[<get_ $name>](self.[<get_ $name _id>]()?)
                    }

                    #[doc = "Returns " $name " data if the symbol is a " $name "."]
                    #[doc = "# Panics"]
                    #[doc = "Panics if the symbol is not a " $name "."]
                    #[doc = ""]
                    #[doc = "_This function is automatically generated by a macro._"]
                    #[inline(always)]
                    #[must_use]
                    pub fn [<get_ $name _or_panic>](self, db: &Database) -> &[<$name:camel Data>] {
                        self.[<get_ $name>](db).unwrap()
                    }
                )*
            }
        }
    };
}

define_symbol_struct!(
    module,
    enum,
    struct,
    function,
    interface,
    tuple_like_struct,
    type_alias
);

impl Symbol {
    /// Returns the name of the symbol.
    #[inline(always)]
    #[must_use]
    pub fn name(self, db: &Database) -> Option<IdentifierAST> {
        match self {
            Self::Module(module) => unreachable!(),
            Self::Enum(id) => db.get_enum(id).map(|e| e.name),
            Self::Struct(id) => db.get_struct(id).map(|s| s.name),
            Self::Function(id) => db.get_function(id).map(|f| f.name),
            Self::Interface(id) => db.get_interface(id).map(|i| i.name),
            Self::TupleLikeStruct(id) => db.get_tuple_like_struct(id).map(|s| s.name),
            Self::TypeAlias(id) => db.get_type_alias(id).map(|a| a.name),
        }
    }

    /// Returns the name's identifier ID of the symbol.
    #[inline(always)]
    #[must_use]
    pub fn name_id(self, db: &Database) -> Option<IdentifierID> {
        self.name(db).map(|name| name.id)
    }

    /// Returns the name's identifier ID location of the symbol.
    ///
    /// # Panics
    /// Panics if the symbol doesn't have a name.
    #[inline(always)]
    #[must_use]
    pub fn name_id_or_panic(self, db: &Database) -> IdentifierID {
        self.name_id(db).unwrap()
    }

    /// Returns the name's location of the symbol.
    #[inline(always)]
    #[must_use]
    pub fn name_location(self, db: &Database) -> Option<Location> {
        self.name(db).map(|name| name.location)
    }

    /// Returns the name's location of the symbol.
    ///
    /// # Panics
    /// Panics if the symbol doesn't have a name.
    #[inline(always)]
    #[must_use]
    pub fn name_location_or_panic(self, db: &Database) -> Location {
        self.name_location(db).unwrap()
    }
}

/// A data that Stellar compiler has about an enum.
pub struct EnumData {
    pub visibility: Visibility,
    pub name: IdentifierAST,
    pub module: ModuleID,
    pub implements: Vec<TypeConstructor>,
    pub predicates: Vec<PredicateID>,
    pub items: FxHashMap<IdentifierID, EnumItemID>,
    pub methods: FxHashMap<IdentifierID, FunctionID>,
}

impl EnumData {
    /// Creates a new enum data object in the database and returns its ID.
    #[inline(always)]
    #[must_use]
    pub fn alloc(
        db: &mut Database,
        visibility: Visibility,
        name: IdentifierAST,
        module: ModuleID,
    ) -> EnumID {
        db.add_enum(Self::new(visibility, name, module))
    }

    /// Creates a new enum data object.
    #[inline(always)]
    #[must_use]
    pub fn new(visibility: Visibility, name: IdentifierAST, module: ModuleID) -> Self {
        Self {
            visibility,
            name,
            module,
            implements: Vec::new(),
            predicates: Vec::new(),
            items: FxHashMap::default(),
            methods: FxHashMap::default(),
        }
    }
}

/// A unique ID that maps to [`EnumData`].
#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]
pub struct EnumID(pub usize);

/// A data that Stellar compiler has about a struct.
pub struct StructData {
    pub visibility: Visibility,
    pub name: IdentifierAST,
    pub module: ModuleID,
    pub predicates: Vec<PredicateID>,
    pub fields: FxHashMap<IdentifierID, FieldID>,
    pub methods: FxHashMap<IdentifierID, FunctionID>,
}

impl StructData {
    /// Creates a new struct data object in the database and returns its ID.
    #[inline(always)]
    #[must_use]
    pub fn alloc(
        db: &mut Database,
        visibility: Visibility,
        name: IdentifierAST,
        module: ModuleID,
    ) -> StructID {
        db.add_struct(Self::new(visibility, name, module))
    }

    /// Creates a new struct data object.
    #[inline(always)]
    #[must_use]
    pub fn new(visibility: Visibility, name: IdentifierAST, module: ModuleID) -> Self {
        Self {
            visibility,
            name,
            module,
            predicates: Vec::new(),
            fields: FxHashMap::default(),
            methods: FxHashMap::default(),
        }
    }
}

/// A unique ID that maps to [`StructData`].
#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]
pub struct StructID(pub usize);

/// A data that Stellar compiler has about a function.
pub struct TupleLikeStructData {
    pub visibility: Visibility,
    pub name: IdentifierAST,
    pub fields: Vec<(Visibility, Type)>,
    pub module: ModuleID,
}

impl TupleLikeStructData {
    /// Creates a new tuple-like struct data object in the database and returns its ID.
    #[inline(always)]
    #[must_use]
    pub fn alloc(
        db: &mut Database,
        visibility: Visibility,
        name: IdentifierAST,
        module: ModuleID,
    ) -> TupleLikeStructID {
        db.add_tuple_like_struct(Self::new(visibility, name, module))
    }

    /// Creates a new tuple-like struct data object.
    #[inline(always)]
    #[must_use]
    pub fn new(visibility: Visibility, name: IdentifierAST, module: ModuleID) -> Self {
        Self {
            visibility,
            name,
            fields: Vec::new(),
            module,
        }
    }
}

/// A unique ID that maps to [`TupleLikeStructData`].
#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]
pub struct TupleLikeStructID(pub usize);

/// A data that Stellar compiler has about a field.
pub struct FieldData {
    pub visibility: Visibility,
    pub name: IdentifierAST,
    pub ty: Type,
}

impl FieldData {
    /// Creates a new field data object in the database and returns its ID.
    #[inline(always)]
    #[must_use]
    pub fn alloc(
        db: &mut Database,
        visibility: Visibility,
        name: IdentifierAST,
        ty: Type,
    ) -> FieldID {
        db.add_field(Self::new(visibility, name, ty))
    }

    /// Creates a new field data object.
    #[inline(always)]
    #[must_use]
    pub fn new(visibility: Visibility, name: IdentifierAST, ty: Type) -> Self {
        Self {
            visibility,
            name,
            ty,
        }
    }
}

/// A unique ID that maps to [`FieldData`].
pub struct FieldID(pub usize);

/// A data that Stellar compiler has about a predicate.
pub struct PredicateData {
    pub ty: Type,
    pub bounds: Vec<TypeConstructor>,
}

impl PredicateData {
    /// Creates a new predicate data object in the database and returns its ID.
    #[inline(always)]
    #[must_use]
    pub fn alloc(db: &mut Database, ty: Type, bounds: Vec<TypeConstructor>) -> PredicateID {
        db.add_predicate(Self::new(ty, bounds))
    }

    /// Creates a new predicate data object.
    #[inline(always)]
    #[must_use]
    pub fn new(ty: Type, bounds: Vec<TypeConstructor>) -> Self {
        Self { ty, bounds }
    }
}

/// A unique ID that maps to [`PredicateData`].
pub struct PredicateID(pub usize);

/// A data that Stellar compiler has about an enum item.
pub struct EnumItemData {
    pub name: IdentifierAST,
    pub module: ModuleID,
}

impl EnumItemData {
    /// Creates a new enum item data object in the database and returns its ID.
    #[inline(always)]
    #[must_use]
    pub fn alloc(db: &mut Database, name: IdentifierAST, module: ModuleID) -> EnumItemID {
        db.add_enum_item(Self::new(name, module))
    }

    /// Creates a new enum item data object.
    #[inline(always)]
    #[must_use]
    pub fn new(name: IdentifierAST, module: ModuleID) -> Self {
        Self { name, module }
    }
}

/// A unique ID that maps to [`EnumItemData`].
#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]
pub struct EnumItemID(pub usize);

/// A data that Stellar compiler has about a function.
pub struct FunctionData {
    pub name: IdentifierAST,
    pub visibility: Visibility,
    pub module: ModuleID,
}

/// A unique ID that maps to [`FunctionData`].
#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]
pub struct FunctionID(pub usize);

impl FunctionData {
    /// Creates a new function data object in the database and returns its ID.
    #[inline(always)]
    #[must_use]
    pub fn alloc(
        db: &mut Database,
        name: IdentifierAST,
        visibility: Visibility,
        module: ModuleID,
    ) -> FunctionID {
        db.add_function(Self::new(name, visibility, module))
    }

    /// Creates a new function data object.
    #[inline(always)]
    #[must_use]
    pub fn new(name: IdentifierAST, visibility: Visibility, module: ModuleID) -> Self {
        Self {
            name,
            visibility,
            module,
        }
    }
}

/// A data that Stellar compiler has about an interface.
pub struct InterfaceData {
    pub visibility: Visibility,
    pub name: IdentifierAST,
    pub module: ModuleID,
    pub predicates: Vec<PredicateID>,
    pub methods: FxHashMap<IdentifierID, FunctionID>,
}

impl InterfaceData {
    /// Creates a new interface data object in the database and returns its ID.
    #[inline(always)]
    #[must_use]
    pub fn alloc(
        db: &mut Database,
        visibility: Visibility,
        name: IdentifierAST,
        module: ModuleID,
    ) -> InterfaceID {
        db.add_interface(Self::new(visibility, name, module))
    }

    /// Creates a new interface data object.
    #[inline(always)]
    #[must_use]
    pub fn new(visibility: Visibility, name: IdentifierAST, module: ModuleID) -> Self {
        Self {
            visibility,
            name,
            module,
            predicates: Vec::new(),
            methods: FxHashMap::default(),
        }
    }
}

/// A unique ID that maps to [`InterfaceData`].
#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]
pub struct InterfaceID(pub usize);

/// A data that Stellar compiler has about a module.
pub struct TypeAliasData {
    pub visibility: Visibility,
    pub name: IdentifierAST,
    pub ty: Type,
    pub module: ModuleID,
}

impl TypeAliasData {
    /// Creates a new type alias data object in the database and returns its ID.
    #[inline(always)]
    #[must_use]
    pub fn alloc(
        db: &mut Database,
        visibility: Visibility,
        name: IdentifierAST,
        module: ModuleID,
    ) -> TypeAliasID {
        db.add_type_alias(Self::new(visibility, name, module))
    }

    /// Creates a new type alias data object.
    #[inline(always)]
    #[must_use]
    pub fn new(visibility: Visibility, name: IdentifierAST, module: ModuleID) -> Self {
        Self {
            visibility,
            name,
            ty: Type::Unknown,
            module,
        }
    }
}

/// A unique ID that maps to [`TypeAliasData`].
#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]
pub struct TypeAliasID(pub usize);

/// A data that Stellar compiler has about a module.
pub struct ModuleData {
    pub name: IdentifierID,
    pub filepath: PathID,
    pub symbols: FxHashMap<IdentifierID, Symbol>,
    pub imports: FxHashMap<IdentifierID, Path>,
    pub resolved_imports: FxHashMap<IdentifierID, Symbol>,
}

impl ModuleData {
    /// Creates a new module data object in the database and returns its ID.
    #[inline(always)]
    #[must_use]
    pub fn alloc(db: &mut Database, name: IdentifierID, filepath: PathID) -> ModuleID {
        db.add_module(Self::new(name, filepath))
    }

    /// Creates a new module data object.
    #[inline(always)]
    #[must_use]
    pub fn new(name: IdentifierID, filepath: PathID) -> Self {
        Self {
            name,
            filepath,
            imports: FxHashMap::default(),
            resolved_imports: FxHashMap::default(),
            symbols: FxHashMap::default(),
        }
    }

    /// Resolves a symbol in the module.
    #[inline(always)]
    #[must_use]
    pub fn get_symbol(&self, id: IdentifierID) -> Option<Symbol> {
        self.symbols.get(&id).copied()
    }

    /// Resolves a symbol in the module.
    ///
    /// # Panics
    /// Panics if the symbol cannot be resolved.
    #[inline(always)]
    #[must_use]
    pub fn get_symbol_or_panic(&self, id: IdentifierID) -> Symbol {
        self.get_symbol(id).unwrap()
    }

    /// Adds a symbol to the module.
    #[inline(always)]
    pub fn add_symbol(&mut self, name: IdentifierID, symbol: Symbol) {
        self.symbols.insert(name, symbol);
    }

    /// Checks if a symbol is contained in the module.
    #[inline(always)]
    #[must_use]
    pub fn contains_symbol(&self, id: IdentifierID) -> bool {
        self.symbols.contains_key(&id)
    }
}

/// A unique ID that maps to [`ModuleData`].
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ModuleID(pub usize);

/// Storage for Stellar compiler entities.
#[derive(Default)]
pub struct Database {
    modules: Vec<ModuleData>,
    enums: Vec<EnumData>,
    enum_items: Vec<EnumItemData>,
    predicates: Vec<PredicateData>,
    structs: Vec<StructData>,
    tuple_like_structs: Vec<TupleLikeStructData>,
    fields: Vec<FieldData>,
    functions: Vec<FunctionData>,
    interfaces: Vec<InterfaceData>,
    type_aliases: Vec<TypeAliasData>,
}

macro_rules! db_methods {
    (
        $($what:ident($whats:ident): $id_ty:ty => $data_ty:ty),*
    ) => {
        $(
            paste! {
                #[doc = "Returns an immutable reference to " $what " data by its ID."]
                #[doc = ""]
                #[doc = "_This function is automatically generated using a macro!_"]
                #[inline(always)]
                #[must_use]
                pub fn [<get_ $what>](&self, id: $id_ty) -> Option<&$data_ty> {
                    self.$whats.get(id.0)
                }

                #[doc = "Returns a mutable reference to " $what " data by its ID."]
                #[doc = ""]
                #[doc = "_This function is automatically generated using a macro!_"]
                #[inline(always)]
                #[must_use]
                pub fn [<get_ $what _mut>](&mut self, id: $id_ty) -> Option<&mut $data_ty> {
                    self.$whats.get_mut(id.0)
                }

                #[doc = "Returns an immutable reference to " $what " data by its ID."]
                #[doc = "# Panics"]
                #[doc = "Panics if " $what " with the given ID is not present in the database storage."]
                #[doc = ""]
                #[doc = "_This function is automatically generated using a macro!_"]
                #[inline(always)]
                #[must_use]
                pub fn [<get_ $what _or_panic>](&self, id: $id_ty) -> &$data_ty {
                    self.$whats.get(id.0).unwrap()
                }

                #[doc = "Returns a mutable reference to " $what " data by its ID."]
                #[doc = "# Panics"]
                #[doc = "Panics if " $what " with the given ID is not present in the database storage."]
                #[doc = ""]
                #[doc = "_This function is automatically generated using a macro!_"]
                #[inline(always)]
                #[must_use]
                pub fn [<get_ $what _mut_or_panic>](&mut self, id: $id_ty) -> &mut $data_ty {
                    self.$whats.get_mut(id.0).unwrap()
                }

                #[doc = "Returns whether " $what " with a given ID is in the database storage."]
                #[doc = ""]
                #[doc = "_This function is automatically generated using a macro!_"]
                #[inline(always)]
                #[must_use]
                pub fn [<contains_ $what>](&self, id: $id_ty) -> bool {
                    id.0 < self.$whats.len()
                }

                #[doc = "Adds a " $what " to the database storage."]
                #[doc = ""]
                #[doc = "_This function is automatically generated using a macro!_"]
                #[inline(always)]
                #[must_use]
                pub fn [<add_ $what>](&mut self, [<$what _>]: $data_ty) -> $id_ty {
                    self.$whats.push([<$what _>]);

                    $id_ty(self.$whats.len() - 1)
                }
            }
        )*
    };
}

impl Database {
    /// Creates a new empty database.
    #[inline(always)]
    #[must_use]
    pub fn new() -> Self {
        Self::default()
    }

    // reduces the size of code in hundreds of times!
    db_methods! {
        module(modules): ModuleID => ModuleData,
        enum(enums): EnumID => EnumData,
        struct(structs): StructID => StructData,

        tuple_like_struct(tuple_like_structs):
            TupleLikeStructID => TupleLikeStructData,

        type_alias(type_aliases): TypeAliasID => TypeAliasData,
        function(functions): FunctionID => FunctionData,
        interface(interfaces): InterfaceID => InterfaceData,
        predicate(predicates): PredicateID => PredicateData,
        enum_item(enum_items): EnumItemID => EnumItemData,
        field(fields): FieldID => FieldData
    }
}

/// Contains database and diagnostics.
#[derive(Default)]
pub struct State {
    db: RwLock<Database>,
    diagnostics: RwLock<Diagnostics>,
    config: Config,
}

pub struct Config {
    pub threads_amount: usize,
}

impl Default for Config {
    #[inline(always)]
    fn default() -> Self {
        Self { threads_amount: 1 }
    }
}

impl Config {
    #[inline(always)]
    #[must_use]
    pub fn new() -> Self {
        Self::default()
    }

    #[inline(always)]
    #[must_use]
    pub fn with_threads_amount(mut self, threads_amount: usize) -> usize {
        self.threads_amount = threads_amount;
        self.threads_amount
    }
}

impl State {
    /// Creates a new empty state.
    #[inline(always)]
    #[must_use]
    pub fn new() -> Self {
        Self::default()
    }

    #[inline(always)]
    #[must_use]
    pub fn with_config(mut self, config: Config) -> Self {
        self.config = config;
        self
    }

    #[inline(always)]
    #[must_use]
    pub fn config(&self) -> &Config {
        &self.config
    }

    /// Returns a reference to database.
    #[inline(always)]
    #[must_use]
    pub const fn db(&self) -> &RwLock<Database> {
        &self.db
    }

    #[inline(always)]
    #[must_use]
    pub fn db_inner(self) -> Database {
        self.db.into_inner()
    }

    #[inline(always)]
    #[must_use]
    pub fn db_lock(&self) -> RwLockReadGuard<Database> {
        self.db.read()
    }

    #[inline(always)]
    #[must_use]
    pub fn db_lock_write(&self) -> RwLockWriteGuard<Database> {
        self.db.write()
    }

    /// Returns a reference to database.
    #[inline(always)]
    #[must_use]
    pub const fn diagnostics(&self) -> &RwLock<Diagnostics> {
        &self.diagnostics
    }

    #[inline(always)]
    #[must_use]
    pub fn diagnostics_inner(self) -> Diagnostics {
        self.diagnostics.into_inner()
    }

    #[inline(always)]
    #[must_use]
    pub fn diagnostics_lock(&self) -> RwLockReadGuard<Diagnostics> {
        self.diagnostics.read()
    }

    #[inline(always)]
    #[must_use]
    pub fn diagnostics_lock_write(&self) -> RwLockWriteGuard<Diagnostics> {
        self.diagnostics.write()
    }
}
