//! Defines [`Symbol`] and [`BuiltinSymbolId`].

use super::*;
use crate::Path;

/// Generates an ADT for all builtin symbols.
macro_rules! builtin_symbols {
    ($($name:ident),*) => {
        paste! {
            /// A builtin symbol's unique ID.
            #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]
            #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
            pub enum BuiltinSymbolId {
                $(
                    [<$name:camel>],
                )*
            }

            impl From<IdentifierId> for BuiltinSymbolId {
                #[inline]
                fn from(id: IdentifierId) -> Self {
                    match id {
                        $(
                            stellar_interner::builtin_identifiers::[<$name:upper>] => Self::[<$name:camel>],
                        )*
                        _ => unimplemented!()
                    }
                }
            }

            impl From<BuiltinSymbolId> for IdentifierId {
                #[inline]
                fn from(id: BuiltinSymbolId) -> Self {
                    match id {
                        $(
                            BuiltinSymbolId::[<$name:camel>] => stellar_interner::builtin_identifiers::[<$name:upper>],
                        )*
                    }
                }
            }
        }
    };
}

/// Generates an ADT for symbols.
macro_rules! symbols {
    ($($name:ident),*) => {
        paste! {
            /// A symbol's unique ID.
            #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]
            #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
            pub enum Symbol {
                $(
                    [<$name:camel>]([<$name:camel Id>]),
                )*
            }

            $(
                impl From<[<$name:camel Id>]> for Symbol {
                    #[inline]
                    fn from(id: [<$name:camel Id>]) -> Self {
                        Self::[<$name:camel>](id)
                    }
                }
            )*

            impl Symbol {
                $(
                    #[doc = "Returns `true` if the symbol is a [`Symbol::" [<$name:camel>] "`]."]
                    #[doc = ""]
                    #[doc = "_This function is automatically generated by a macro._"]
                    #[inline]
                    #[must_use]
                    pub const fn [<is_ $name>](&self) -> bool {
                        matches!(self, Self::[<$name:camel>](_))
                    }

                    #[doc = "Returns [`" [<$name:camel Id>] "`] if the symbol is a [`Symbol::" [<$name:camel>] "`]."]
                    #[doc = ""]
                    #[doc = "_This function is automatically generated by a macro._"]
                    #[inline]
                    #[must_use]
                    pub fn [<to_ $name _or_none>](self) -> Option<[<$name:camel Id>]> {
                        match self {
                            Self::[<$name:camel>](id) => Some(id),
                            _ => None
                        }
                    }

                    #[doc = "Returns [`" [<$name:camel Id>] "`] if the symbol is a [`Symbol::" [<$name:camel>] "`]."]
                    #[doc = "# Panics"]
                    #[doc = "Panics if the symbol is not [`Symbol::" [<$name:camel>] "`]."]
                    #[doc = ""]
                    #[doc = "_This function is automatically generated by a macro._"]
                    #[inline]
                    #[must_use]
                    pub fn [<to_ $name>](self) -> [<$name:camel Id>] {
                        self.[<to_ $name _or_none>]().unwrap()
                    }
                )*
            }
        }
    };
}

builtin_symbols! {
    int8, int16, int32, int64, uint8, uint16, uint32, uint64,
    float32, float64, char, String, List, bool
}

impl From<BuiltinSymbolId> for Path {
    #[inline]
    fn from(id: BuiltinSymbolId) -> Self {
        IdentifierId::from(id).into()
    }
}

symbols! {
    module,
    enum,
    struct,
    function,
    interface,
    tuple_like_struct,
    type_alias,
    enum_item,
    builtin_symbol
}

impl Symbol {
    /// Returns the signature of the symbol.
    #[inline]
    #[must_use]
    pub fn signature(self, db: &Database) -> SignatureId {
        match self {
            Self::Enum(enum_) => enum_.signature(db),
            Self::Struct(struct_) => struct_.signature(db),
            Self::Function(function) => function.signature(db),
            Self::Interface(interface) => interface.signature(db),
            Self::TupleLikeStruct(struct_) => struct_.signature(db),
            Self::TypeAlias(alias) => alias.signature(db),
            Self::EnumItem(_) | Self::Module(_) | Self::BuiltinSymbol(_) => unreachable!(),
        }
    }

    pub fn module(self, db: &Database) -> ModuleId {
        match self {
            Self::Enum(enum_) => enum_.signature(db).module(db),
            Self::Struct(struct_) => struct_.signature(db).module(db),
            Self::Function(function_) => function_.signature(db).module(db),
            Self::Module(module) => module,
            Self::Interface(interface) => interface.signature(db).module(db),
            Self::TupleLikeStruct(struct_) => struct_.signature(db).module(db),
            Self::TypeAlias(alias) => alias.signature(db).module(db),
            Self::EnumItem(item) => item.module(db),
            Self::BuiltinSymbol(_) => DUMMY_MODULE_ID,
        }
    }

    /// Returns the name of the symbol.
    #[inline]
    #[must_use]
    pub fn name(self, db: &Database) -> IdentifierAST {
        match self {
            Self::Module(module) => IdentifierAST {
                location: DUMMY_LOCATION,
                id: module.name(db),
            },
            Self::Enum(enum_) => enum_.signature(db).name(db),
            Self::Struct(struct_) => struct_.signature(db).name(db),
            Self::Function(function) => function.signature(db).name(db),
            Self::Interface(interface) => interface.signature(db).name(db),
            Self::TupleLikeStruct(struct_) => struct_.signature(db).name(db),
            Self::TypeAlias(alias) => alias.signature(db).name(db),
            Self::EnumItem(item) => item.name(db),
            Self::BuiltinSymbol(_) => todo!(),
        }
    }

    #[inline]
    #[must_use]
    pub fn module_item_kind_or_none(self) -> Option<ModuleItemKind> {
        match self {
            Self::Enum(_) => Some(ModuleItemKind::Enum),
            Self::Struct(_) => Some(ModuleItemKind::Struct),
            Self::Function(_) => Some(ModuleItemKind::Function),
            Self::Interface(_) => Some(ModuleItemKind::Interface),
            Self::TupleLikeStruct(_) => Some(ModuleItemKind::TupleLikeStruct),
            Self::TypeAlias(_) => Some(ModuleItemKind::TypeAlias),
            Self::EnumItem(_) | Self::Module(_) | Self::BuiltinSymbol(_) => None,
        }
    }

    #[inline]
    #[must_use]
    pub fn module_item_kind(self) -> ModuleItemKind {
        self.module_item_kind_or_none().unwrap()
    }

    #[inline]
    #[must_use]
    pub fn path(self, db: &Database) -> Path {
        let path = self.module(db).path(db).clone();

        match self {
            Self::Module(_) => path,
            Self::Enum(_)
            | Self::Struct(_)
            | Self::TupleLikeStruct(_)
            | Self::Function(_)
            | Self::TypeAlias(_)
            | Self::Interface(_) => path + self.name(db).id,
            Self::EnumItem(item) => {
                path + item.enum_(db).signature(db).name(db).id + item.name(db).id
            }
            Self::BuiltinSymbol(symbol) => symbol.into(),
        }
    }
}
