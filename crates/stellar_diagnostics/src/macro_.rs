/// **FOR INTERNAL USAGE ONLY!!!**
#[macro_export]
macro_rules! __notes {
    ($diagnostic:ident, ) => {};
    ($diagnostic:ident, notes { $($note:expr)* }) => {
        let $diagnostic = $diagnostic.with_notes(vec![
            $($note),*
        ]);
    }
}

/// **FOR INTERNAL USAGE ONLY!!!**
#[macro_export]
macro_rules! __labels {
    ($diagnostic:ident,) => {};
    ($diagnostic:ident,
     $(primary { $($primary_label:tt)* })*
     $(secondary { $($secondary_label:tt)* } )*
    ) => {
            $(
                $crate::__primary_label!(
                    $diagnostic,
                    $($primary_label)*
                );
            )*

            $(
                $crate::__secondary_label!(
                    $diagnostic,
                    $($secondary_label)*
                );
            )*
    };
}

/// **FOR INTERNAL USAGE ONLY!!!**
#[macro_export]
macro_rules! __primary_label {
    ($diagnostic:ident, $location:expr => $message:expr) => {
        let $diagnostic = $diagnostic.with_label(
            stellar_diagnostics::diagnostic::Label::primary($location).with_message($message),
        );
    };
    ($diagnostic:ident, $location:expr) => {
        let $diagnostic =
            $diagnostic.with_label(stellar_diagnostics::diagnostic::Label::primary($location));
    };
    ($diagnostic:ident,) => {};
}

/// **FOR INTERNAL USAGE ONLY!!!**
#[macro_export]
macro_rules! __secondary_label {
    ($diagnostic:ident, $location:expr => $message:expr) => {
        let $diagnostic = $diagnostic.with_label(
            stellar_diagnostics::diagnostic::Label::secondary($location).with_message($message),
        );
    };
    ($diagnostic:ident, $location:expr) => {
        let $diagnostic =
            $diagnostic.with_label(stellar_diagnostics::diagnostic::Label::secondary($location));
    };
    ($diagnostic:ident,) => {};
}

/// Allows to define diagnostics more efficiently.
///
/// # Example
///
/// ```
/// use stellar_diagnostics::define_diagnostics;
/// use stellar_filesystem::location::Location;
///
/// define_diagnostics! {
///    diagnostic(error) FailedToResolveModule(
///        self,
///        module_name_location: Location,
///        module_name: String,
///        package_name_location: Location,
///        package_name: String
///    ) {
///        code { "E007" }
///        message { format!("failed to resolve the module `{}`", self.module_name) }
///        labels {
///            primary { self.module_name_location }
///            secondary {
///                self.package_name_location => format!(
///                    "package `{}` doesn't contain the submodule `{}`",
///                    self.package_name, self.module_name)
///            }
///        }
///    }
/// }
/// ```
///
/// This macro invokations does few things:
///
/// * Creates a `FailedToResolveModule` struct with given fields.
/// * Automatically creates a constructor (`new` method) for it.
/// * Automatically implements `BuildDiagnostic` trait for a given struct.
#[macro_export]
macro_rules! define_diagnostics {
    {
        $(
            $(#[$attr:meta])*
            diagnostic($severity:ident) $name:ident (
                $self:ident
                $(,
                    $(#[$arg_attr:meta])*
                    $arg_name:ident: $arg_ty:ty
                )*
            ) {
                code { $code:expr }
                message { $message:expr }
                labels { $($labels:tt)* }
                $($note:tt)*
            }
        )*
    } => {
        $(
            $(#[$attr])*
            #[derive(Debug)]
            pub struct $name {
                $(
                    $(#[$arg_attr])*
                    $arg_name: $arg_ty
                ),*
            }

            impl $name {
                #[doc = concat!("A constructor for `", stringify!($name), "` generated by")]
                #[doc = concat!("`stellar_diagnostics::define_diagnostics` macro")]
                #[inline(always)]
                #[must_use]
                pub fn new($($arg_name: impl Into<$arg_ty>),*) -> Self {
                    Self { $($arg_name: $arg_name.into()),* }
                }
            }

            #[allow(clippy::unnecessary_qualification)]
            impl $crate::BuildDiagnostic for $name {
                #[inline(always)]
                fn build($self) -> $crate::diagnostic::Diagnostic {
                    let diagnostic = $crate::diagnostic::Diagnostic::$severity()
                        .with_code($code.to_string())
                        .with_message($message);

                    $crate::__labels!(diagnostic, $($labels)*);
                    $crate::__notes!(diagnostic, $($note)*);

                    diagnostic
                }
            }
        )*
    };
}
