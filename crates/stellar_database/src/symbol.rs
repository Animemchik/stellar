use super::*;

macro_rules! symbols {
    ($($name:ident),*) => {
        paste! {
            /// A symbol's unique ID.
            #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]
            #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
            pub enum Symbol {
                $(
                    [<$name:camel>]([<$name:camel Id>]),
                )*
            }

            impl Symbol {
                $(
                    #[doc = "Returns `true` if the symbol is a [`Symbol::" [<$name:camel>] "`]."]
                    #[doc = ""]
                    #[doc = "_This function is automatically generated by a macro._"]
                    #[inline]
                    #[must_use]
                    pub const fn [<is_ $name>](&self) -> bool {
                        matches!(self, Self::[<$name:camel>](_))
                    }

                    #[doc = "Returns [`" [<$name:camel Id>] "`] if the symbol is a [`Symbol::" [<$name:camel>] "`]."]
                    #[doc = ""]
                    #[doc = "_This function is automatically generated by a macro._"]
                    #[inline]
                    #[must_use]
                    pub fn [<to_ $name _or_none>](self) -> Option<[<$name:camel Id>]> {
                        match self {
                            Self::[<$name:camel>](id) => Some(id),
                            _ => None
                        }
                    }

                    #[doc = "Returns [`" [<$name:camel Id>] "`] if the symbol is a [`Symbol::" [<$name:camel>] "`]."]
                    #[doc = "# Panics"]
                    #[doc = "Panics if the symbol is not [`Symbol::" [<$name:camel>] "`]."]
                    #[doc = ""]
                    #[doc = "_This function is automatically generated by a macro._"]
                    #[inline]
                    #[must_use]
                    pub fn [<to_ $name>](self) -> [<$name:camel Id>] {
                        self.[<to_ $name _or_none>]().unwrap()
                    }
                )*
            }
        }
    };
}

symbols! {
    module,
    enum,
    struct,
    function,
    interface,
    tuple_like_struct,
    type_alias,
    enum_item
}

impl Symbol {
    /// Returns the signature of the symbol.
    #[inline]
    #[must_use]
    pub fn signature(self, db: &Database) -> SignatureId {
        match self {
            Self::Enum(enum_) => enum_.signature(db),
            Self::Struct(struct_) => struct_.signature(db),
            Self::Function(function) => function.signature(db),
            Self::Interface(interface) => interface.signature(db),
            Self::TupleLikeStruct(struct_) => struct_.signature(db),
            Self::TypeAlias(alias) => alias.signature(db),
            Self::EnumItem(_) | Self::Module(_) => unreachable!(),
        }
    }

    pub fn module(self, db: &Database) -> ModuleId {
        match self {
            Self::Enum(enum_) => enum_.signature(db).module(db),
            Self::Struct(struct_) => struct_.signature(db).module(db),
            Self::Function(function_) => function_.signature(db).module(db),
            Self::Module(module) => module,
            Self::Interface(interface) => interface.signature(db).module(db),
            Self::TupleLikeStruct(struct_) => struct_.signature(db).module(db),
            Self::TypeAlias(alias) => alias.signature(db).module(db),
            Self::EnumItem(item) => item.module(db),
        }
    }

    /// Returns the name of the symbol.
    #[inline]
    #[must_use]
    pub fn name(self, db: &Database) -> IdentifierAST {
        match self {
            Self::Module(module) => IdentifierAST {
                location: DUMMY_LOCATION,
                id: db.module(module).name,
            },
            Self::Enum(enum_) => enum_.signature(db).name(db),
            Self::Struct(struct_) => struct_.signature(db).name(db),
            Self::Function(function) => function.signature(db).name(db),
            Self::Interface(interface) => interface.signature(db).name(db),
            Self::TupleLikeStruct(struct_) => struct_.signature(db).name(db),
            Self::TypeAlias(alias) => alias.signature(db).name(db),
            Self::EnumItem(item) => item.name(db),
        }
    }

    #[inline]
    #[must_use]
    pub fn module_item_kind_or_none(self) -> Option<ModuleItemKind> {
        match self {
            Self::Enum(_) => Some(ModuleItemKind::Enum),
            Self::Struct(_) => Some(ModuleItemKind::Struct),
            Self::Function(_) => Some(ModuleItemKind::Function),
            Self::Interface(_) => Some(ModuleItemKind::Interface),
            Self::TupleLikeStruct(_) => Some(ModuleItemKind::TupleLikeStruct),
            Self::TypeAlias(_) => Some(ModuleItemKind::TypeAlias),
            Self::EnumItem(_) | Self::Module(_) => None,
        }
    }

    #[inline]
    #[must_use]
    pub fn module_item_kind(self) -> ModuleItemKind {
        self.module_item_kind_or_none().unwrap()
    }
}
